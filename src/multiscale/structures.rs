//! Structure-to-local mapping for generating building and dungeon interiors.
//!
//! Provides BSP room generation, dungeon layouts, and structure interiors
//! at local scale.

use rand::Rng;
use rand_chacha::ChaCha8Rng;
use noise::{NoiseFn, Perlin};

use super::local::{LocalChunk, LocalTile, LocalTerrain, LocalFeature, Material, StoneType, LairType};
use super::LOCAL_SIZE;

/// BSP tree node for room partitioning
#[derive(Clone, Debug)]
pub struct BspNode {
    /// X position within chunk
    pub x: usize,
    /// Y position within chunk
    pub y: usize,
    /// Width
    pub width: usize,
    /// Height
    pub height: usize,
    /// Left/top child
    pub left: Option<Box<BspNode>>,
    /// Right/bottom child
    pub right: Option<Box<BspNode>>,
    /// Room within this node (if leaf)
    pub room: Option<Room>,
}

/// A room generated by BSP
#[derive(Clone, Debug)]
pub struct Room {
    /// X position
    pub x: usize,
    /// Y position
    pub y: usize,
    /// Width
    pub width: usize,
    /// Height
    pub height: usize,
    /// Room type
    pub room_type: RoomType,
}

/// Types of dungeon rooms
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum RoomType {
    /// Generic room
    Generic,
    /// Entrance hall
    Entrance,
    /// Storage room
    Storage,
    /// Treasure room
    Treasure,
    /// Shrine/altar room
    Shrine,
    /// Prison/cell
    Prison,
    /// Library
    Library,
    /// Barracks
    Barracks,
    /// Boss chamber (larger)
    BossChamber,
}

impl Room {
    /// Get center coordinates
    pub fn center(&self) -> (usize, usize) {
        (self.x + self.width / 2, self.y + self.height / 2)
    }
}

/// Minimum room size for BSP
const MIN_ROOM_SIZE: usize = 8;

/// Minimum node size for BSP splitting
const MIN_NODE_SIZE: usize = 12;

impl BspNode {
    /// Create a new BSP node
    pub fn new(x: usize, y: usize, width: usize, height: usize) -> Self {
        Self {
            x,
            y,
            width,
            height,
            left: None,
            right: None,
            room: None,
        }
    }

    /// Split this node recursively
    pub fn split(&mut self, rng: &mut ChaCha8Rng, min_size: usize, depth: usize) {
        if depth == 0 || self.width < min_size * 2 || self.height < min_size * 2 {
            return;
        }

        // Decide split direction based on aspect ratio
        let split_horizontal = if (self.width as f32) > (self.height as f32) * 1.25 {
            false // Split vertically (make narrower)
        } else if (self.height as f32) > (self.width as f32) * 1.25 {
            true // Split horizontally (make shorter)
        } else {
            rng.gen_bool(0.5)
        };

        if split_horizontal {
            // Split horizontally
            let split_y = rng.gen_range(min_size..self.height - min_size);
            self.left = Some(Box::new(BspNode::new(
                self.x,
                self.y,
                self.width,
                split_y,
            )));
            self.right = Some(Box::new(BspNode::new(
                self.x,
                self.y + split_y,
                self.width,
                self.height - split_y,
            )));
        } else {
            // Split vertically
            let split_x = rng.gen_range(min_size..self.width - min_size);
            self.left = Some(Box::new(BspNode::new(
                self.x,
                self.y,
                split_x,
                self.height,
            )));
            self.right = Some(Box::new(BspNode::new(
                self.x + split_x,
                self.y,
                self.width - split_x,
                self.height,
            )));
        }

        // Recursively split children
        if let Some(ref mut left) = self.left {
            left.split(rng, min_size, depth - 1);
        }
        if let Some(ref mut right) = self.right {
            right.split(rng, min_size, depth - 1);
        }
    }

    /// Generate rooms in leaf nodes
    pub fn generate_rooms(&mut self, rng: &mut ChaCha8Rng) {
        if self.left.is_none() && self.right.is_none() {
            // This is a leaf - generate room
            let margin = 1;
            let room_width = rng.gen_range(MIN_ROOM_SIZE..=self.width.saturating_sub(margin * 2));
            let room_height = rng.gen_range(MIN_ROOM_SIZE..=self.height.saturating_sub(margin * 2));

            let room_x = self.x + rng.gen_range(margin..=self.width.saturating_sub(room_width + margin).max(margin));
            let room_y = self.y + rng.gen_range(margin..=self.height.saturating_sub(room_height + margin).max(margin));

            let room_type = match rng.gen_range(0..10) {
                0 => RoomType::Treasure,
                1 => RoomType::Shrine,
                2 => RoomType::Library,
                3 => RoomType::Storage,
                4 => RoomType::Prison,
                5 => RoomType::Barracks,
                _ => RoomType::Generic,
            };

            self.room = Some(Room {
                x: room_x,
                y: room_y,
                width: room_width,
                height: room_height,
                room_type,
            });
        } else {
            // Recurse into children
            if let Some(ref mut left) = self.left {
                left.generate_rooms(rng);
            }
            if let Some(ref mut right) = self.right {
                right.generate_rooms(rng);
            }
        }
    }

    /// Collect all rooms from the tree
    pub fn collect_rooms(&self) -> Vec<Room> {
        let mut rooms = Vec::new();
        self.collect_rooms_recursive(&mut rooms);
        rooms
    }

    fn collect_rooms_recursive(&self, rooms: &mut Vec<Room>) {
        if let Some(ref room) = self.room {
            rooms.push(room.clone());
        }
        if let Some(ref left) = self.left {
            left.collect_rooms_recursive(rooms);
        }
        if let Some(ref right) = self.right {
            right.collect_rooms_recursive(rooms);
        }
    }
}

/// Ruin state for a room
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum RuinState {
    /// Intact room
    Intact,
    /// Partially collapsed - rubble, damaged walls
    Collapsed,
    /// Flooded with water
    Flooded,
    /// Decayed - cracks, missing floor tiles
    Decayed,
}

/// Generate a dungeon level using BSP
pub fn generate_dungeon_bsp(
    chunk: &mut LocalChunk,
    z_level: i16,
    rng: &mut ChaCha8Rng,
) -> Vec<Room> {
    // Fill with walls first
    for y in 0..LOCAL_SIZE {
        for x in 0..LOCAL_SIZE {
            chunk.set(x, y, z_level, LocalTile::new(
                LocalTerrain::ConstructedWall { material: Material::Stone },
                Material::Stone
            ));
        }
    }

    // Create BSP tree
    let mut root = BspNode::new(1, 1, LOCAL_SIZE - 2, LOCAL_SIZE - 2);
    root.split(rng, MIN_NODE_SIZE, 3);
    root.generate_rooms(rng);

    let rooms = root.collect_rooms();

    // Carve rooms
    for room in &rooms {
        carve_room(chunk, room, z_level, rng);
    }

    // Connect rooms with corridors
    connect_rooms(chunk, &rooms, z_level, rng);

    // Apply ruin effects to some rooms (30% chance per room)
    for room in &rooms {
        if rng.gen_bool(0.30) {
            let ruin_state = match rng.gen_range(0..3) {
                0 => RuinState::Collapsed,
                1 => RuinState::Flooded,
                _ => RuinState::Decayed,
            };
            apply_ruin_effects(chunk, room, z_level, ruin_state, rng);
        }
    }

    rooms
}

/// Apply ruin effects to a room
fn apply_ruin_effects(
    chunk: &mut LocalChunk,
    room: &Room,
    z: i16,
    state: RuinState,
    rng: &mut ChaCha8Rng,
) {
    match state {
        RuinState::Intact => {}
        RuinState::Collapsed => collapse_room(chunk, room, z, rng),
        RuinState::Flooded => flood_room(chunk, room, z, rng),
        RuinState::Decayed => decay_room(chunk, room, z, rng),
    }
}

/// Collapse a room - add rubble, destroy some walls
fn collapse_room(chunk: &mut LocalChunk, room: &Room, z: i16, rng: &mut ChaCha8Rng) {
    // Add rubble piles (40% of floor tiles)
    for y in room.y..(room.y + room.height).min(LOCAL_SIZE) {
        for x in room.x..(room.x + room.width).min(LOCAL_SIZE) {
            if rng.gen_bool(0.40) {
                let tile = chunk.get_mut(x, y, z);
                if matches!(tile.terrain, LocalTerrain::ConstructedFloor { .. }) {
                    tile.feature = LocalFeature::Rubble;
                }
            }
        }
    }

    // Partially destroy walls (create gaps)
    let wall_positions = [
        (room.x.saturating_sub(1), room.y + room.height / 2), // left
        (room.x + room.width, room.y + room.height / 2),      // right
        (room.x + room.width / 2, room.y.saturating_sub(1)),  // top
        (room.x + room.width / 2, room.y + room.height),      // bottom
    ];

    for (wx, wy) in wall_positions {
        if wx < LOCAL_SIZE && wy < LOCAL_SIZE && rng.gen_bool(0.5) {
            let tile = chunk.get_mut(wx, wy, z);
            if matches!(tile.terrain, LocalTerrain::ConstructedWall { .. }) {
                tile.terrain = LocalTerrain::ConstructedFloor { material: Material::Stone };
                tile.feature = LocalFeature::Rubble;
            }
        }
    }

    // Add some stone debris replacing floor
    for _ in 0..rng.gen_range(1..4) {
        let x = room.x + rng.gen_range(0..room.width.max(1));
        let y = room.y + rng.gen_range(0..room.height.max(1));
        if x < LOCAL_SIZE && y < LOCAL_SIZE {
            chunk.set(x, y, z, LocalTile::new(
                LocalTerrain::Stone { stone_type: super::local::StoneType::Granite },
                Material::Stone
            ));
        }
    }
}

/// Flood a room with water
fn flood_room(chunk: &mut LocalChunk, room: &Room, z: i16, rng: &mut ChaCha8Rng) {
    // Determine flood level (shallow or deep)
    let is_deep = rng.gen_bool(0.3);

    for y in room.y..(room.y + room.height).min(LOCAL_SIZE) {
        for x in room.x..(room.x + room.width).min(LOCAL_SIZE) {
            let tile = chunk.get_mut(x, y, z);
            if matches!(tile.terrain, LocalTerrain::ConstructedFloor { .. }) {
                // Clear any features
                tile.feature = LocalFeature::None;

                // Fill with water
                if is_deep {
                    tile.terrain = LocalTerrain::DeepWater;
                    tile.material = Material::Water;
                } else {
                    tile.terrain = LocalTerrain::ShallowWater;
                    tile.material = Material::Water;
                }
            }
        }
    }

    // Add some dry spots near edges (shallow floods only)
    if !is_deep {
        for y in room.y..(room.y + room.height).min(LOCAL_SIZE) {
            for x in room.x..(room.x + room.width).min(LOCAL_SIZE) {
                let at_edge = x == room.x || x == room.x + room.width - 1 ||
                              y == room.y || y == room.y + room.height - 1;
                if at_edge && rng.gen_bool(0.4) {
                    chunk.set(x, y, z, LocalTile::new(
                        LocalTerrain::ConstructedFloor { material: Material::Stone },
                        Material::Stone
                    ));
                }
            }
        }
    }
}

/// Decay a room - cracks, missing tiles, vegetation
fn decay_room(chunk: &mut LocalChunk, room: &Room, z: i16, rng: &mut ChaCha8Rng) {
    for y in room.y..(room.y + room.height).min(LOCAL_SIZE) {
        for x in room.x..(room.x + room.width).min(LOCAL_SIZE) {
            let tile = chunk.get_mut(x, y, z);

            if matches!(tile.terrain, LocalTerrain::ConstructedFloor { .. }) {
                let roll = rng.gen_range(0..100);
                if roll < 15 {
                    // Missing floor tile - dirt showing through
                    tile.terrain = LocalTerrain::DirtFloor;
                    tile.material = Material::Dirt;
                } else if roll < 25 {
                    // Cracked/damaged floor
                    tile.terrain = LocalTerrain::Gravel;
                    tile.material = Material::Stone;
                } else if roll < 30 {
                    // Moss/vegetation growing
                    tile.feature = LocalFeature::Mushroom;
                }
            }
        }
    }

    // Crack some walls
    let wall_check_positions: Vec<(usize, usize)> = (room.y.saturating_sub(1)..=(room.y + room.height).min(LOCAL_SIZE - 1))
        .flat_map(|y| {
            [(room.x.saturating_sub(1), y), ((room.x + room.width).min(LOCAL_SIZE - 1), y)]
        })
        .chain(
            (room.x.saturating_sub(1)..=(room.x + room.width).min(LOCAL_SIZE - 1))
                .flat_map(|x| {
                    [(x, room.y.saturating_sub(1)), (x, (room.y + room.height).min(LOCAL_SIZE - 1))]
                })
        )
        .collect();

    for (wx, wy) in wall_check_positions {
        if wx < LOCAL_SIZE && wy < LOCAL_SIZE {
            let tile = chunk.get_mut(wx, wy, z);
            if matches!(tile.terrain, LocalTerrain::ConstructedWall { .. }) && rng.gen_bool(0.15) {
                // Cracked wall
                tile.feature = LocalFeature::Rubble;
            }
        }
    }
}

/// Carve a room into the chunk
fn carve_room(chunk: &mut LocalChunk, room: &Room, z: i16, rng: &mut ChaCha8Rng) {
    // Carve floor
    for y in room.y..(room.y + room.height).min(LOCAL_SIZE) {
        for x in room.x..(room.x + room.width).min(LOCAL_SIZE) {
            chunk.set(x, y, z, LocalTile::new(
                LocalTerrain::ConstructedFloor { material: Material::Stone },
                Material::Stone
            ));
        }
    }

    // Add features based on room type
    let (cx, cy) = room.center();
    match room.room_type {
        RoomType::Treasure => {
            if cx < LOCAL_SIZE && cy < LOCAL_SIZE {
                chunk.get_mut(cx, cy, z).feature = LocalFeature::Chest;
            }
        }
        RoomType::Shrine => {
            if cx < LOCAL_SIZE && cy < LOCAL_SIZE {
                chunk.get_mut(cx, cy, z).feature = LocalFeature::Altar;
            }
            // Add torches
            for (dx, dy) in [(-2, 0), (2, 0), (0, -2), (0, 2)] {
                let tx = (cx as i32 + dx).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
                let ty = (cy as i32 + dy).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
                if matches!(chunk.get(tx, ty, z).terrain, LocalTerrain::ConstructedFloor { .. }) {
                    chunk.get_mut(tx, ty, z).feature = LocalFeature::Torch;
                }
            }
        }
        RoomType::Library => {
            // Add pillars along walls (placeholder for bookshelves)
            for x in (room.x + 1)..(room.x + room.width - 1).min(LOCAL_SIZE) {
                if x < LOCAL_SIZE && room.y + 1 < LOCAL_SIZE {
                    if rng.gen_bool(0.7) {
                        chunk.get_mut(x, room.y + 1, z).feature = LocalFeature::Pillar;
                    }
                }
            }
        }
        RoomType::Storage => {
            // Add rubble (placeholder for barrels/crates)
            for _ in 0..rng.gen_range(2..5) {
                let bx = rng.gen_range(room.x + 1..(room.x + room.width - 1).min(LOCAL_SIZE));
                let by = rng.gen_range(room.y + 1..(room.y + room.height - 1).min(LOCAL_SIZE));
                if chunk.get(bx, by, z).feature == LocalFeature::None {
                    chunk.get_mut(bx, by, z).feature = LocalFeature::Rubble;
                }
            }
        }
        RoomType::Prison => {
            // Add bars (pillars as placeholder)
            for y in (room.y + 2..(room.y + room.height - 2).min(LOCAL_SIZE)).step_by(3) {
                for x in (room.x + 2..(room.x + room.width - 2).min(LOCAL_SIZE)).step_by(3) {
                    if matches!(chunk.get(x, y, z).terrain, LocalTerrain::ConstructedFloor { .. }) {
                        chunk.get_mut(x, y, z).feature = LocalFeature::Pillar;
                    }
                }
            }
        }
        RoomType::Barracks => {
            // Add rubble along walls
            for i in 0..(room.width / 3) {
                let bx = room.x + 1 + i * 3;
                if bx < LOCAL_SIZE && room.y + 1 < LOCAL_SIZE {
                    chunk.get_mut(bx, room.y + 1, z).feature = LocalFeature::Rubble;
                }
            }
        }
        RoomType::BossChamber => {
            // Add pillars in corners
            for (dx, dy) in [(2, 2), (-2, 2), (2, -2), (-2, -2)] {
                let px = (cx as i32 + dx).clamp(room.x as i32, (room.x + room.width) as i32 - 1) as usize;
                let py = (cy as i32 + dy).clamp(room.y as i32, (room.y + room.height) as i32 - 1) as usize;
                if px < LOCAL_SIZE && py < LOCAL_SIZE {
                    if matches!(chunk.get(px, py, z).terrain, LocalTerrain::ConstructedFloor { .. }) {
                        chunk.get_mut(px, py, z).feature = LocalFeature::Pillar;
                    }
                }
            }
            // Add treasure at center
            if cx < LOCAL_SIZE && cy < LOCAL_SIZE {
                chunk.get_mut(cx, cy, z).feature = LocalFeature::Chest;
            }
        }
        _ => {}
    }

    // Add torch in one corner
    if rng.gen_bool(0.6) {
        let tx = room.x + 1;
        let ty = room.y + 1;
        if tx < LOCAL_SIZE && ty < LOCAL_SIZE && chunk.get(tx, ty, z).feature == LocalFeature::None {
            chunk.get_mut(tx, ty, z).feature = LocalFeature::Torch;
        }
    }
}

/// Connect rooms with corridors
fn connect_rooms(chunk: &mut LocalChunk, rooms: &[Room], z: i16, rng: &mut ChaCha8Rng) {
    if rooms.len() < 2 {
        return;
    }

    // Connect each room to the next (forms a spanning path)
    for i in 0..rooms.len() - 1 {
        let (x1, y1) = rooms[i].center();
        let (x2, y2) = rooms[i + 1].center();

        // L-shaped corridor
        if rng.gen_bool(0.5) {
            // Horizontal then vertical
            carve_corridor_h(chunk, x1, x2, y1, z);
            carve_corridor_v(chunk, y1, y2, x2, z);
        } else {
            // Vertical then horizontal
            carve_corridor_v(chunk, y1, y2, x1, z);
            carve_corridor_h(chunk, x1, x2, y2, z);
        }
    }

    // Add doors at room entrances
    for room in rooms {
        add_doors_to_room(chunk, room, z, rng);
    }
}

/// Carve horizontal corridor
fn carve_corridor_h(chunk: &mut LocalChunk, x1: usize, x2: usize, y: usize, z: i16) {
    let start_x = x1.min(x2);
    let end_x = x1.max(x2);

    for x in start_x..=end_x.min(LOCAL_SIZE - 1) {
        if y < LOCAL_SIZE {
            chunk.set(x, y, z, LocalTile::new(
                LocalTerrain::ConstructedFloor { material: Material::Stone },
                Material::Stone
            ));
        }
    }
}

/// Carve vertical corridor
fn carve_corridor_v(chunk: &mut LocalChunk, y1: usize, y2: usize, x: usize, z: i16) {
    let start_y = y1.min(y2);
    let end_y = y1.max(y2);

    for y in start_y..=end_y.min(LOCAL_SIZE - 1) {
        if x < LOCAL_SIZE {
            chunk.set(x, y, z, LocalTile::new(
                LocalTerrain::ConstructedFloor { material: Material::Stone },
                Material::Stone
            ));
        }
    }
}

/// Add doors at room entrances
fn add_doors_to_room(chunk: &mut LocalChunk, room: &Room, z: i16, rng: &mut ChaCha8Rng) {
    // Check each wall for corridors
    // Top wall
    for x in room.x..(room.x + room.width).min(LOCAL_SIZE) {
        if room.y > 0 && x < LOCAL_SIZE {
            let above = room.y - 1;
            if matches!(chunk.get(x, above, z).terrain, LocalTerrain::ConstructedFloor { .. })
                && matches!(chunk.get(x, room.y, z).terrain, LocalTerrain::ConstructedFloor { .. })
            {
                if rng.gen_bool(0.7) {
                    chunk.get_mut(x, room.y, z).feature = LocalFeature::Door { open: false };
                }
                break;
            }
        }
    }
}

/// Generate a complete multi-level dungeon with properly connected stairs
/// Returns the entrance position (x, y) of the first room on the top level
pub fn generate_dungeon_levels(
    chunk: &mut LocalChunk,
    start_z: i16,
    num_levels: usize,
    rng: &mut ChaCha8Rng,
) -> Option<(usize, usize)> {
    if num_levels == 0 {
        return None;
    }

    // First pass: generate all levels and collect room data
    let mut all_levels: Vec<(i16, Vec<Room>)> = Vec::new();

    for i in 0..num_levels {
        let z = start_z - i as i16;
        if z < chunk.z_min {
            break;
        }
        let rooms = generate_dungeon_bsp(chunk, z, rng);
        if !rooms.is_empty() {
            all_levels.push((z, rooms));
        }
    }

    if all_levels.is_empty() {
        return None;
    }

    // Get entrance position from first level
    let entrance_pos = all_levels[0].1.first().map(|r| r.center());

    // Second pass: add stairs connecting adjacent levels
    for i in 0..all_levels.len() {
        let (z, ref rooms) = all_levels[i];

        // Add stairs up in first room (except on top level - that connects to surface)
        if i > 0 && !rooms.is_empty() {
            let (cx, cy) = rooms[0].center();
            if cx < LOCAL_SIZE && cy < LOCAL_SIZE {
                chunk.get_mut(cx, cy, z).feature = LocalFeature::StairsUp;
            }
        }

        // Add stairs down connecting to the level below (if there is one)
        if i + 1 < all_levels.len() && rooms.len() > 1 {
            let (next_z, ref next_rooms) = all_levels[i + 1];

            // Find a good connection point - use first room of level below
            if let Some(next_room) = next_rooms.first() {
                let (next_cx, next_cy) = next_room.center();

                // Find closest room on current level to place stairs down
                let mut best_room_idx = rooms.len() - 1;
                let mut best_dist = usize::MAX;
                for (idx, room) in rooms.iter().enumerate() {
                    let (rx, ry) = room.center();
                    let dist = ((rx as i32 - next_cx as i32).abs() +
                               (ry as i32 - next_cy as i32).abs()) as usize;
                    if dist < best_dist {
                        best_dist = dist;
                        best_room_idx = idx;
                    }
                }

                // Place stairs down at the closest room's position to the level below's entrance
                let (cx, cy) = rooms[best_room_idx].center();
                if cx < LOCAL_SIZE && cy < LOCAL_SIZE {
                    chunk.get_mut(cx, cy, z).feature = LocalFeature::StairsDown;
                }

                // Carve a corridor on the level below from stairs up to first room if needed
                // and place stairs up at the connection point
                if next_cx < LOCAL_SIZE && next_cy < LOCAL_SIZE {
                    // Place stairs up on level below at same position as stairs down
                    chunk.get_mut(cx, cy, next_z).feature = LocalFeature::StairsUp;
                    // Make sure the tile is floor, not wall
                    chunk.get_mut(cx, cy, next_z).terrain =
                        LocalTerrain::ConstructedFloor { material: Material::Stone };
                }
            }
        }
    }

    entrance_pos
}

// =============================================================================
// MINOR STRUCTURE GENERATORS
// =============================================================================

/// Generate a graveyard with scattered graves, tombs, and optionally a mausoleum
pub fn generate_graveyard(
    chunk: &mut LocalChunk,
    surface_z: i16,
    rng: &mut ChaCha8Rng,
) {
    let noise = Perlin::new(rng.gen());

    // Number of gravestones (10-30)
    let num_graves = rng.gen_range(10..30);

    // Track placed grave positions to avoid overlap
    let mut placed: Vec<(usize, usize)> = Vec::new();

    // Place gravestones in a scattered pattern
    for _ in 0..num_graves {
        // Try to find a valid position
        for _ in 0..10 {
            let x = rng.gen_range(4..LOCAL_SIZE - 4);
            let y = rng.gen_range(4..LOCAL_SIZE - 4);

            // Check if too close to existing graves
            let too_close = placed.iter().any(|(px, py)| {
                let dx = (*px as i32 - x as i32).abs();
                let dy = (*py as i32 - y as i32).abs();
                dx < 2 && dy < 2
            });

            if !too_close {
                placed.push((x, y));
                chunk.get_mut(x, y, surface_z).feature = LocalFeature::Pillar; // Gravestone
                break;
            }
        }
    }

    // Add 1-3 larger tombs
    let num_tombs = rng.gen_range(1..4);
    for _ in 0..num_tombs {
        let x = rng.gen_range(8..LOCAL_SIZE - 8);
        let y = rng.gen_range(8..LOCAL_SIZE - 8);

        // Create a small tomb structure (3x3)
        for dy in -1i32..=1 {
            for dx in -1i32..=1 {
                let tx = (x as i32 + dx).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
                let ty = (y as i32 + dy).clamp(0, LOCAL_SIZE as i32 - 1) as usize;

                if dx == 0 && dy == 0 {
                    // Center - tomb chest
                    chunk.set(tx, ty, surface_z, LocalTile::new(
                        LocalTerrain::ConstructedFloor { material: Material::Stone },
                        Material::Stone
                    ));
                    chunk.get_mut(tx, ty, surface_z).feature = LocalFeature::Chest;
                } else if dx.abs() == 1 && dy.abs() == 1 {
                    // Corners - walls
                    chunk.set(tx, ty, surface_z, LocalTile::new(
                        LocalTerrain::ConstructedWall { material: Material::Stone },
                        Material::Stone
                    ));
                } else {
                    // Edges - floor
                    chunk.set(tx, ty, surface_z, LocalTile::new(
                        LocalTerrain::ConstructedFloor { material: Material::Stone },
                        Material::Stone
                    ));
                }
            }
        }
    }

    // 20% chance of a mausoleum
    if rng.gen_bool(0.2) {
        generate_mausoleum(chunk, surface_z, rng);
    }

    // 50% chance of an iron fence around perimeter
    if rng.gen_bool(0.5) {
        generate_fence_perimeter(chunk, surface_z, 2, rng);
    }

    // Add some dead trees
    for _ in 0..rng.gen_range(2..5) {
        let x = rng.gen_range(2..LOCAL_SIZE - 2);
        let y = rng.gen_range(2..LOCAL_SIZE - 2);
        if chunk.get(x, y, surface_z).feature == LocalFeature::None {
            chunk.get_mut(x, y, surface_z).feature = LocalFeature::Tree { height: rng.gen_range(2..4) };
        }
    }
}

/// Generate a small mausoleum building
fn generate_mausoleum(chunk: &mut LocalChunk, surface_z: i16, rng: &mut ChaCha8Rng) {
    let cx = LOCAL_SIZE / 2;
    let cy = LOCAL_SIZE / 2;
    let width = rng.gen_range(6..10);
    let height = rng.gen_range(6..10);

    let x1 = cx - width / 2;
    let y1 = cy - height / 2;

    // Build walls
    for x in x1..x1 + width {
        for y in y1..y1 + height {
            if x < LOCAL_SIZE && y < LOCAL_SIZE {
                let is_wall = x == x1 || x == x1 + width - 1 || y == y1 || y == y1 + height - 1;
                let is_door = y == y1 && x == cx;

                if is_door {
                    chunk.set(x, y, surface_z, LocalTile::new(
                        LocalTerrain::ConstructedFloor { material: Material::Stone },
                        Material::Stone
                    ));
                    chunk.get_mut(x, y, surface_z).feature = LocalFeature::Door { open: false };
                } else if is_wall {
                    chunk.set(x, y, surface_z, LocalTile::new(
                        LocalTerrain::ConstructedWall { material: Material::Stone },
                        Material::Stone
                    ));
                } else {
                    chunk.set(x, y, surface_z, LocalTile::new(
                        LocalTerrain::ConstructedFloor { material: Material::Stone },
                        Material::Stone
                    ));
                }
            }
        }
    }

    // Add altar in center
    chunk.get_mut(cx, cy, surface_z).feature = LocalFeature::Altar;

    // Add torches
    chunk.get_mut(x1 + 1, y1 + 1, surface_z).feature = LocalFeature::Torch;
    chunk.get_mut(x1 + width - 2, y1 + 1, surface_z).feature = LocalFeature::Torch;
}

/// Generate a fence around the perimeter
fn generate_fence_perimeter(chunk: &mut LocalChunk, surface_z: i16, margin: usize, rng: &mut ChaCha8Rng) {
    // North and South edges
    for x in margin..LOCAL_SIZE - margin {
        if rng.gen_bool(0.8) {
            chunk.get_mut(x, margin, surface_z).feature = LocalFeature::Pillar;
            chunk.get_mut(x, LOCAL_SIZE - margin - 1, surface_z).feature = LocalFeature::Pillar;
        }
    }
    // East and West edges
    for y in margin..LOCAL_SIZE - margin {
        if rng.gen_bool(0.8) {
            chunk.get_mut(margin, y, surface_z).feature = LocalFeature::Pillar;
            chunk.get_mut(LOCAL_SIZE - margin - 1, y, surface_z).feature = LocalFeature::Pillar;
        }
    }

    // Gate in north wall
    let gate_x = LOCAL_SIZE / 2;
    chunk.get_mut(gate_x, margin, surface_z).feature = LocalFeature::None;
    chunk.get_mut(gate_x + 1, margin, surface_z).feature = LocalFeature::None;
}

/// Generate a battlefield with bones, weapons, and war memorial
pub fn generate_battlefield(
    chunk: &mut LocalChunk,
    surface_z: i16,
    rng: &mut ChaCha8Rng,
) {
    let noise = Perlin::new(rng.gen());

    // Scatter bone piles (using rubble as placeholder)
    let num_bone_piles = rng.gen_range(15..40);
    for _ in 0..num_bone_piles {
        let x = rng.gen_range(2..LOCAL_SIZE - 2);
        let y = rng.gen_range(2..LOCAL_SIZE - 2);

        // Use noise for clustering
        let nx = x as f64 / LOCAL_SIZE as f64 * 4.0;
        let ny = y as f64 / LOCAL_SIZE as f64 * 4.0;
        let noise_val = noise.get([nx, ny]);

        if noise_val > -0.3 && chunk.get(x, y, surface_z).feature == LocalFeature::None {
            chunk.get_mut(x, y, surface_z).feature = LocalFeature::Rubble;
        }
    }

    // 1-2 craters from siege weapons or explosions
    let num_craters = rng.gen_range(1..3);
    for _ in 0..num_craters {
        let cx = rng.gen_range(10..LOCAL_SIZE - 10);
        let cy = rng.gen_range(10..LOCAL_SIZE - 10);
        let radius = rng.gen_range(3..7);

        for dy in -(radius as i32)..=(radius as i32) {
            for dx in -(radius as i32)..=(radius as i32) {
                let dist = ((dx * dx + dy * dy) as f32).sqrt();
                if dist <= radius as f32 {
                    let x = (cx as i32 + dx).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
                    let y = (cy as i32 + dy).clamp(0, LOCAL_SIZE as i32 - 1) as usize;

                    if dist < (radius / 2) as f32 {
                        // Crater center - exposed stone/dirt
                        chunk.set(x, y, surface_z, LocalTile::new(LocalTerrain::Gravel, Material::Stone));
                    } else {
                        // Crater edge - charred/dead grass
                        chunk.set(x, y, surface_z, LocalTile::new(LocalTerrain::DirtFloor, Material::Dirt));
                    }
                }
            }
        }
    }

    // War memorial in center
    let memorial_x = LOCAL_SIZE / 2;
    let memorial_y = LOCAL_SIZE / 2;

    // Stone platform for memorial
    for dy in -2i32..=2 {
        for dx in -2i32..=2 {
            let x = (memorial_x as i32 + dx).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
            let y = (memorial_y as i32 + dy).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
            chunk.set(x, y, surface_z, LocalTile::new(
                LocalTerrain::ConstructedFloor { material: Material::Stone },
                Material::Stone
            ));
        }
    }
    chunk.get_mut(memorial_x, memorial_y, surface_z).feature = LocalFeature::Statue;

    // Scattered rusted weapons (using pillar as placeholder for sword/spear)
    let num_weapons = rng.gen_range(5..15);
    for _ in 0..num_weapons {
        let x = rng.gen_range(2..LOCAL_SIZE - 2);
        let y = rng.gen_range(2..LOCAL_SIZE - 2);
        if chunk.get(x, y, surface_z).feature == LocalFeature::None {
            chunk.get_mut(x, y, surface_z).feature = LocalFeature::Pillar; // Rusted weapon
        }
    }
}

/// Generate a monster lair based on lair type
pub fn generate_monster_lair(
    chunk: &mut LocalChunk,
    surface_z: i16,
    lair_type: LairType,
    rng: &mut ChaCha8Rng,
) {
    match lair_type {
        LairType::WebCluster => generate_spider_lair(chunk, surface_z, rng),
        LairType::BoneNest => generate_bone_nest(chunk, surface_z, rng),
        LairType::SlimeTrail => generate_slime_lair(chunk, surface_z, rng),
        LairType::AntMound => generate_ant_mound(chunk, surface_z, rng),
        LairType::BeeHive => generate_bee_hive(chunk, surface_z, rng),
        LairType::Generic => generate_generic_lair(chunk, surface_z, rng),
    }
}

/// Generate a spider web lair
fn generate_spider_lair(chunk: &mut LocalChunk, surface_z: i16, rng: &mut ChaCha8Rng) {
    let noise = Perlin::new(rng.gen());

    // Web coverage - more dense in center
    let center_x = LOCAL_SIZE / 2;
    let center_y = LOCAL_SIZE / 2;

    for y in 0..LOCAL_SIZE {
        for x in 0..LOCAL_SIZE {
            let dx = x as i32 - center_x as i32;
            let dy = y as i32 - center_y as i32;
            let dist = ((dx * dx + dy * dy) as f32).sqrt();

            let nx = x as f64 / LOCAL_SIZE as f64 * 6.0;
            let ny = y as f64 / LOCAL_SIZE as f64 * 6.0;
            let noise_val = noise.get([nx, ny]);

            // More webs closer to center
            let web_chance = (1.0 - dist / (LOCAL_SIZE as f32 * 0.7)).max(0.0) * 0.3;
            if noise_val > 0.0 && rng.gen_bool(web_chance as f64) {
                if chunk.get(x, y, surface_z).feature == LocalFeature::None {
                    // Use boulder as web placeholder
                    chunk.get_mut(x, y, surface_z).feature = LocalFeature::Boulder;
                }
            }
        }
    }

    // Cocoons (trapped prey) - use chest as placeholder
    let num_cocoons = rng.gen_range(3..8);
    for _ in 0..num_cocoons {
        let x = rng.gen_range(center_x - 10..center_x + 10).clamp(2, LOCAL_SIZE - 3);
        let y = rng.gen_range(center_y - 10..center_y + 10).clamp(2, LOCAL_SIZE - 3);
        if chunk.get(x, y, surface_z).feature == LocalFeature::None {
            chunk.get_mut(x, y, surface_z).feature = LocalFeature::Chest; // Cocoon
        }
    }

    // Dead trees with webs
    for _ in 0..rng.gen_range(3..7) {
        let x = rng.gen_range(5..LOCAL_SIZE - 5);
        let y = rng.gen_range(5..LOCAL_SIZE - 5);
        if chunk.get(x, y, surface_z).feature == LocalFeature::None {
            chunk.get_mut(x, y, surface_z).feature = LocalFeature::Tree { height: rng.gen_range(3..6) };
        }
    }
}

/// Generate a bone nest (predator lair)
fn generate_bone_nest(chunk: &mut LocalChunk, surface_z: i16, rng: &mut ChaCha8Rng) {
    let center_x = LOCAL_SIZE / 2;
    let center_y = LOCAL_SIZE / 2;

    // Central nest area with bones/rubble
    let nest_radius = rng.gen_range(6..12);
    for dy in -(nest_radius as i32)..=(nest_radius as i32) {
        for dx in -(nest_radius as i32)..=(nest_radius as i32) {
            let dist = ((dx * dx + dy * dy) as f32).sqrt();
            if dist <= nest_radius as f32 {
                let x = (center_x as i32 + dx).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
                let y = (center_y as i32 + dy).clamp(0, LOCAL_SIZE as i32 - 1) as usize;

                // More bones in center
                let bone_chance = (1.0 - dist / nest_radius as f32) * 0.7;
                if rng.gen_bool(bone_chance as f64) {
                    chunk.get_mut(x, y, surface_z).feature = LocalFeature::Rubble; // Bones
                }
            }
        }
    }

    // Scattered carcasses (use chest as placeholder)
    let num_carcasses = rng.gen_range(2..6);
    for _ in 0..num_carcasses {
        let x = rng.gen_range(center_x - 8..center_x + 8).clamp(2, LOCAL_SIZE - 3);
        let y = rng.gen_range(center_y - 8..center_y + 8).clamp(2, LOCAL_SIZE - 3);
        if chunk.get(x, y, surface_z).feature == LocalFeature::None {
            chunk.get_mut(x, y, surface_z).feature = LocalFeature::Chest;
        }
    }

    // Territory markers around perimeter (pillars)
    for _ in 0..rng.gen_range(4..8) {
        let angle = rng.gen_range(0.0..std::f64::consts::TAU);
        let dist = rng.gen_range(15..22) as f64;
        let x = (center_x as f64 + angle.cos() * dist).clamp(2.0, (LOCAL_SIZE - 3) as f64) as usize;
        let y = (center_y as f64 + angle.sin() * dist).clamp(2.0, (LOCAL_SIZE - 3) as f64) as usize;
        if chunk.get(x, y, surface_z).feature == LocalFeature::None {
            chunk.get_mut(x, y, surface_z).feature = LocalFeature::Pillar; // Territory marker
        }
    }
}

/// Generate a slime lair with trails and pools
fn generate_slime_lair(chunk: &mut LocalChunk, surface_z: i16, rng: &mut ChaCha8Rng) {
    let noise = Perlin::new(rng.gen());

    // Slime pools (shallow water)
    let num_pools = rng.gen_range(3..8);
    for _ in 0..num_pools {
        let cx = rng.gen_range(8..LOCAL_SIZE - 8);
        let cy = rng.gen_range(8..LOCAL_SIZE - 8);
        let radius = rng.gen_range(2..6);

        for dy in -(radius as i32)..=(radius as i32) {
            for dx in -(radius as i32)..=(radius as i32) {
                let dist = ((dx * dx + dy * dy) as f32).sqrt();
                if dist <= radius as f32 {
                    let x = (cx as i32 + dx).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
                    let y = (cy as i32 + dy).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
                    chunk.set(x, y, surface_z, LocalTile::new(LocalTerrain::ShallowWater, Material::Water));
                }
            }
        }
    }

    // Slime trails connecting pools (mud paths)
    for y in 0..LOCAL_SIZE {
        for x in 0..LOCAL_SIZE {
            let nx = x as f64 / LOCAL_SIZE as f64 * 8.0;
            let ny = y as f64 / LOCAL_SIZE as f64 * 8.0;
            let noise_val = noise.get([nx, ny]);

            if noise_val > 0.5 && chunk.get(x, y, surface_z).terrain != LocalTerrain::ShallowWater {
                chunk.set(x, y, surface_z, LocalTile::new(LocalTerrain::Mud, Material::Mud));
            }
        }
    }
}

/// Generate an ant mound structure
fn generate_ant_mound(chunk: &mut LocalChunk, surface_z: i16, rng: &mut ChaCha8Rng) {
    let center_x = LOCAL_SIZE / 2;
    let center_y = LOCAL_SIZE / 2;

    // Main mound (raised dirt area)
    let mound_radius = rng.gen_range(8..15);
    for dy in -(mound_radius as i32)..=(mound_radius as i32) {
        for dx in -(mound_radius as i32)..=(mound_radius as i32) {
            let dist = ((dx * dx + dy * dy) as f32).sqrt();
            if dist <= mound_radius as f32 {
                let x = (center_x as i32 + dx).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
                let y = (center_y as i32 + dy).clamp(0, LOCAL_SIZE as i32 - 1) as usize;

                // Dirt floor for the mound
                chunk.set(x, y, surface_z, LocalTile::new(LocalTerrain::DirtFloor, Material::Dirt));

                // Entrance holes (stairs down)
                if dist < 3.0 && rng.gen_bool(0.3) {
                    chunk.get_mut(x, y, surface_z).feature = LocalFeature::StairsDown;
                }
            }
        }
    }

    // Ring of disturbed earth around mound
    for dy in -((mound_radius + 3) as i32)..=((mound_radius + 3) as i32) {
        for dx in -((mound_radius + 3) as i32)..=((mound_radius + 3) as i32) {
            let dist = ((dx * dx + dy * dy) as f32).sqrt();
            if dist > mound_radius as f32 && dist <= (mound_radius + 3) as f32 {
                let x = (center_x as i32 + dx).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
                let y = (center_y as i32 + dy).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
                if rng.gen_bool(0.5) {
                    chunk.set(x, y, surface_z, LocalTile::new(LocalTerrain::Gravel, Material::Stone));
                }
            }
        }
    }
}

/// Generate a bee hive structure
fn generate_bee_hive(chunk: &mut LocalChunk, surface_z: i16, rng: &mut ChaCha8Rng) {
    // Large tree with hive
    let tree_x = LOCAL_SIZE / 2;
    let tree_y = LOCAL_SIZE / 2;

    // The tree
    chunk.get_mut(tree_x, tree_y, surface_z).feature = LocalFeature::Tree { height: rng.gen_range(6..10) };

    // Hive structure around tree base (honey = rubble as placeholder)
    for dy in -2i32..=2 {
        for dx in -2i32..=2 {
            if dx == 0 && dy == 0 {
                continue; // Skip tree
            }
            let x = (tree_x as i32 + dx).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
            let y = (tree_y as i32 + dy).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
            if rng.gen_bool(0.6) {
                chunk.get_mut(x, y, surface_z).feature = LocalFeature::Rubble; // Honeycomb
            }
        }
    }

    // Surrounding flowers (bushes as placeholder)
    let num_flowers = rng.gen_range(15..30);
    for _ in 0..num_flowers {
        let x = rng.gen_range(5..LOCAL_SIZE - 5);
        let y = rng.gen_range(5..LOCAL_SIZE - 5);
        let dx = x as i32 - tree_x as i32;
        let dy = y as i32 - tree_y as i32;
        let dist = ((dx * dx + dy * dy) as f32).sqrt();
        if dist > 4.0 && chunk.get(x, y, surface_z).feature == LocalFeature::None {
            chunk.get_mut(x, y, surface_z).feature = LocalFeature::Bush;
        }
    }
}

/// Generate a generic territory lair
fn generate_generic_lair(chunk: &mut LocalChunk, surface_z: i16, rng: &mut ChaCha8Rng) {
    let center_x = LOCAL_SIZE / 2;
    let center_y = LOCAL_SIZE / 2;

    // Central den area - trampled/clear
    let den_radius = rng.gen_range(5..10);
    for dy in -(den_radius as i32)..=(den_radius as i32) {
        for dx in -(den_radius as i32)..=(den_radius as i32) {
            let dist = ((dx * dx + dy * dy) as f32).sqrt();
            if dist <= den_radius as f32 {
                let x = (center_x as i32 + dx).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
                let y = (center_y as i32 + dy).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
                chunk.set(x, y, surface_z, LocalTile::new(LocalTerrain::DirtFloor, Material::Dirt));
            }
        }
    }

    // Scattered bones/remains
    let num_remains = rng.gen_range(5..15);
    for _ in 0..num_remains {
        let x = rng.gen_range(center_x - 15..center_x + 15).clamp(2, LOCAL_SIZE - 3);
        let y = rng.gen_range(center_y - 15..center_y + 15).clamp(2, LOCAL_SIZE - 3);
        if chunk.get(x, y, surface_z).feature == LocalFeature::None {
            chunk.get_mut(x, y, surface_z).feature = LocalFeature::Rubble;
        }
    }

    // Claw marks on trees (trees as markers)
    for _ in 0..rng.gen_range(3..6) {
        let angle = rng.gen_range(0.0..std::f64::consts::TAU);
        let dist = rng.gen_range(12..20) as f64;
        let x = (center_x as f64 + angle.cos() * dist).clamp(2.0, (LOCAL_SIZE - 3) as f64) as usize;
        let y = (center_y as f64 + angle.sin() * dist).clamp(2.0, (LOCAL_SIZE - 3) as f64) as usize;
        if chunk.get(x, y, surface_z).feature == LocalFeature::None {
            chunk.get_mut(x, y, surface_z).feature = LocalFeature::Tree { height: rng.gen_range(4..8) };
        }
    }
}

/// Generate a shrine or monument structure
pub fn generate_shrine(
    chunk: &mut LocalChunk,
    surface_z: i16,
    rng: &mut ChaCha8Rng,
) {
    let center_x = LOCAL_SIZE / 2;
    let center_y = LOCAL_SIZE / 2;

    // Determine shrine type
    let shrine_type = rng.gen_range(0..4);

    match shrine_type {
        0 => {
            // Simple altar shrine
            // Stone platform
            let platform_radius = rng.gen_range(3..6);
            for dy in -(platform_radius as i32)..=(platform_radius as i32) {
                for dx in -(platform_radius as i32)..=(platform_radius as i32) {
                    let dist = ((dx * dx + dy * dy) as f32).sqrt();
                    if dist <= platform_radius as f32 {
                        let x = (center_x as i32 + dx).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
                        let y = (center_y as i32 + dy).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
                        chunk.set(x, y, surface_z, LocalTile::new(
                            LocalTerrain::ConstructedFloor { material: Material::Stone },
                            Material::Stone
                        ));
                    }
                }
            }
            chunk.get_mut(center_x, center_y, surface_z).feature = LocalFeature::Altar;
        }
        1 => {
            // Statue shrine
            // Cobblestone path leading to statue
            for i in 0..15 {
                let y = center_y + 10 - i;
                if y < LOCAL_SIZE {
                    chunk.set(center_x, y, surface_z, LocalTile::new(LocalTerrain::Cobblestone, Material::Stone));
                    if center_x > 0 {
                        chunk.set(center_x - 1, y, surface_z, LocalTile::new(LocalTerrain::Cobblestone, Material::Stone));
                    }
                    if center_x < LOCAL_SIZE - 1 {
                        chunk.set(center_x + 1, y, surface_z, LocalTile::new(LocalTerrain::Cobblestone, Material::Stone));
                    }
                }
            }
            // Statue on pedestal
            for dy in -1i32..=1 {
                for dx in -1i32..=1 {
                    let x = (center_x as i32 + dx).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
                    let y = (center_y as i32 + dy).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
                    chunk.set(x, y, surface_z, LocalTile::new(
                        LocalTerrain::ConstructedFloor { material: Material::Stone },
                        Material::Stone
                    ));
                }
            }
            chunk.get_mut(center_x, center_y, surface_z).feature = LocalFeature::Statue;
        }
        2 => {
            // Obelisk/pillar
            // Circle of stones
            let circle_radius = 6;
            for i in 0..8 {
                let angle = (i as f64 / 8.0) * std::f64::consts::TAU;
                let x = (center_x as f64 + angle.cos() * circle_radius as f64) as usize;
                let y = (center_y as f64 + angle.sin() * circle_radius as f64) as usize;
                if x < LOCAL_SIZE && y < LOCAL_SIZE {
                    chunk.get_mut(x, y, surface_z).feature = LocalFeature::Pillar;
                }
            }
            // Central obelisk
            chunk.set(center_x, center_y, surface_z, LocalTile::new(
                LocalTerrain::ConstructedFloor { material: Material::Stone },
                Material::Stone
            ));
            chunk.get_mut(center_x, center_y, surface_z).feature = LocalFeature::Pillar;
        }
        _ => {
            // Roadside shrine (boundary/milestone)
            // Small shelter
            for dy in -1i32..=1 {
                for dx in -2i32..=2 {
                    let x = (center_x as i32 + dx).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
                    let y = (center_y as i32 + dy).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
                    if dy == -1 || dy == 1 {
                        chunk.set(x, y, surface_z, LocalTile::new(
                            LocalTerrain::ConstructedWall { material: Material::Stone },
                            Material::Stone
                        ));
                    } else {
                        chunk.set(x, y, surface_z, LocalTile::new(
                            LocalTerrain::ConstructedFloor { material: Material::Stone },
                            Material::Stone
                        ));
                    }
                }
            }
            chunk.get_mut(center_x, center_y, surface_z).feature = LocalFeature::Altar;
        }
    }

    // Add some decorative trees/bushes around
    for _ in 0..rng.gen_range(4..10) {
        let x = rng.gen_range(5..LOCAL_SIZE - 5);
        let y = rng.gen_range(5..LOCAL_SIZE - 5);
        let dx = x as i32 - center_x as i32;
        let dy = y as i32 - center_y as i32;
        let dist = ((dx * dx + dy * dy) as f32).sqrt();
        if dist > 8.0 && chunk.get(x, y, surface_z).feature == LocalFeature::None {
            if rng.gen_bool(0.5) {
                chunk.get_mut(x, y, surface_z).feature = LocalFeature::Tree { height: rng.gen_range(4..7) };
            } else {
                chunk.get_mut(x, y, surface_z).feature = LocalFeature::Bush;
            }
        }
    }
}

/// Generate ruins of an old structure
pub fn generate_ruins(
    chunk: &mut LocalChunk,
    surface_z: i16,
    rng: &mut ChaCha8Rng,
) {
    let noise = Perlin::new(rng.gen());

    // Determine ruin type
    let ruin_type = rng.gen_range(0..5);

    match ruin_type {
        0 => {
            // Ruined building/house
            let width = rng.gen_range(10..18);
            let height = rng.gen_range(8..14);
            let x1 = (LOCAL_SIZE - width) / 2;
            let y1 = (LOCAL_SIZE - height) / 2;

            for y in y1..y1 + height {
                for x in x1..x1 + width {
                    if x < LOCAL_SIZE && y < LOCAL_SIZE {
                        let is_wall = x == x1 || x == x1 + width - 1 || y == y1 || y == y1 + height - 1;

                        // Use noise to determine if wall section is intact
                        let nx = x as f64 * 0.2;
                        let ny = y as f64 * 0.2;
                        let wall_intact = noise.get([nx, ny]) > -0.3;

                        if is_wall && wall_intact {
                            chunk.set(x, y, surface_z, LocalTile::new(
                                LocalTerrain::ConstructedWall { material: Material::Stone },
                                Material::Stone
                            ));
                            // Some walls have rubble
                            if rng.gen_bool(0.2) {
                                chunk.get_mut(x, y, surface_z).feature = LocalFeature::Rubble;
                            }
                        } else if is_wall {
                            // Collapsed wall section
                            chunk.set(x, y, surface_z, LocalTile::new(LocalTerrain::Gravel, Material::Stone));
                            chunk.get_mut(x, y, surface_z).feature = LocalFeature::Rubble;
                        } else {
                            // Interior floor
                            chunk.set(x, y, surface_z, LocalTile::new(
                                LocalTerrain::ConstructedFloor { material: Material::Stone },
                                Material::Stone
                            ));
                            // Random debris inside
                            if rng.gen_bool(0.15) {
                                chunk.get_mut(x, y, surface_z).feature = LocalFeature::Rubble;
                            }
                        }
                    }
                }
            }
        }
        1 => {
            // Ruined tower
            let center_x = LOCAL_SIZE / 2;
            let center_y = LOCAL_SIZE / 2;
            let radius = rng.gen_range(5..9);

            for dy in -(radius as i32 + 2)..=(radius as i32 + 2) {
                for dx in -(radius as i32 + 2)..=(radius as i32 + 2) {
                    let x = (center_x as i32 + dx).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
                    let y = (center_y as i32 + dy).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
                    let dist = ((dx * dx + dy * dy) as f32).sqrt();

                    if dist <= radius as f32 {
                        chunk.set(x, y, surface_z, LocalTile::new(
                            LocalTerrain::ConstructedFloor { material: Material::Stone },
                            Material::Stone
                        ));
                    } else if dist <= (radius + 1) as f32 {
                        // Wall ring
                        let nx = dx as f64 * 0.5;
                        let ny = dy as f64 * 0.5;
                        if noise.get([nx, ny]) > -0.2 {
                            chunk.set(x, y, surface_z, LocalTile::new(
                                LocalTerrain::ConstructedWall { material: Material::Stone },
                                Material::Stone
                            ));
                        } else {
                            chunk.set(x, y, surface_z, LocalTile::new(LocalTerrain::Gravel, Material::Stone));
                            chunk.get_mut(x, y, surface_z).feature = LocalFeature::Rubble;
                        }
                    }
                }
            }

            // Central collapsed section
            chunk.get_mut(center_x, center_y, surface_z).feature = LocalFeature::Rubble;
        }
        2 => {
            // Abandoned cart/waystation
            let cart_x = LOCAL_SIZE / 2;
            let cart_y = LOCAL_SIZE / 2;

            // Cart remains (small rectangle)
            for dy in -1i32..=2 {
                for dx in -2i32..=2 {
                    let x = (cart_x as i32 + dx).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
                    let y = (cart_y as i32 + dy).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
                    chunk.set(x, y, surface_z, LocalTile::new(LocalTerrain::WoodFloor, Material::Dirt));
                    if rng.gen_bool(0.3) {
                        chunk.get_mut(x, y, surface_z).feature = LocalFeature::Rubble;
                    }
                }
            }
            // Wheels (pillars as placeholder)
            chunk.get_mut(cart_x - 2, cart_y - 1, surface_z).feature = LocalFeature::Pillar;
            chunk.get_mut(cart_x + 2, cart_y - 1, surface_z).feature = LocalFeature::Pillar;
            chunk.get_mut(cart_x - 2, cart_y + 2, surface_z).feature = LocalFeature::Pillar;
            chunk.get_mut(cart_x + 2, cart_y + 2, surface_z).feature = LocalFeature::Pillar;

            // Scattered goods
            for _ in 0..rng.gen_range(3..8) {
                let x = rng.gen_range(cart_x - 8..cart_x + 8).clamp(2, LOCAL_SIZE - 3);
                let y = rng.gen_range(cart_y - 8..cart_y + 8).clamp(2, LOCAL_SIZE - 3);
                if chunk.get(x, y, surface_z).feature == LocalFeature::None {
                    chunk.get_mut(x, y, surface_z).feature = LocalFeature::Barrel;
                }
            }
        }
        3 => {
            // Dried well
            let well_x = LOCAL_SIZE / 2;
            let well_y = LOCAL_SIZE / 2;

            // Well structure
            for dy in -2i32..=2 {
                for dx in -2i32..=2 {
                    let x = (well_x as i32 + dx).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
                    let y = (well_y as i32 + dy).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
                    let dist = ((dx * dx + dy * dy) as f32).sqrt();

                    if dist <= 1.5 {
                        chunk.set(x, y, surface_z, LocalTile::new(LocalTerrain::Gravel, Material::Stone));
                    } else if dist <= 2.5 {
                        chunk.set(x, y, surface_z, LocalTile::new(
                            LocalTerrain::ConstructedWall { material: Material::Stone },
                            Material::Stone
                        ));
                    }
                }
            }
            chunk.get_mut(well_x, well_y, surface_z).feature = LocalFeature::Well;

            // Path to well
            for i in 0..10 {
                let y = well_y + 3 + i;
                if y < LOCAL_SIZE {
                    chunk.set(well_x, y, surface_z, LocalTile::new(LocalTerrain::Cobblestone, Material::Stone));
                }
            }
        }
        _ => {
            // Overgrown garden/farm
            // Faded rows of cultivation
            for row in 0..6 {
                let y = 10 + row * 6;
                if y < LOCAL_SIZE - 5 {
                    for x in 8..LOCAL_SIZE - 8 {
                        if rng.gen_bool(0.7) {
                            chunk.set(x, y, surface_z, LocalTile::new(LocalTerrain::DirtFloor, Material::Dirt));
                            // Random plants/weeds
                            if rng.gen_bool(0.3) {
                                chunk.get_mut(x, y, surface_z).feature = LocalFeature::Bush;
                            }
                        }
                    }
                }
            }

            // Broken fence posts
            for y in [8, LOCAL_SIZE - 9] {
                for x in (6..LOCAL_SIZE - 6).step_by(4) {
                    if rng.gen_bool(0.7) {
                        chunk.get_mut(x, y, surface_z).feature = LocalFeature::Pillar;
                    }
                }
            }

            // Foundation of farmhouse
            let house_x = LOCAL_SIZE - 15;
            let house_y = LOCAL_SIZE / 2;
            for dy in -3i32..=3 {
                for dx in -4i32..=4 {
                    let x = (house_x as i32 + dx).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
                    let y = (house_y as i32 + dy).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
                    chunk.set(x, y, surface_z, LocalTile::new(
                        LocalTerrain::ConstructedFloor { material: Material::Stone },
                        Material::Stone
                    ));
                    if rng.gen_bool(0.1) {
                        chunk.get_mut(x, y, surface_z).feature = LocalFeature::Rubble;
                    }
                }
            }
        }
    }

    // Add vegetation overgrowth
    for _ in 0..rng.gen_range(10..25) {
        let x = rng.gen_range(3..LOCAL_SIZE - 3);
        let y = rng.gen_range(3..LOCAL_SIZE - 3);
        if chunk.get(x, y, surface_z).feature == LocalFeature::None {
            if rng.gen_bool(0.6) {
                chunk.get_mut(x, y, surface_z).feature = LocalFeature::Bush;
            } else {
                chunk.get_mut(x, y, surface_z).feature = LocalFeature::Tree { height: rng.gen_range(3..6) };
            }
        }
    }
}

// =============================================================================
// VILLAGE GENERATOR
// =============================================================================

/// Building types for villages
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum BuildingType {
    House,
    Shop,
    Tavern,
    Blacksmith,
    Chapel,
    StorageHut,
    Farm,
}

/// A building in a village
#[derive(Clone, Debug)]
pub struct VillageBuilding {
    pub x: usize,
    pub y: usize,
    pub width: usize,
    pub height: usize,
    pub building_type: BuildingType,
    pub has_garden: bool,
}

impl VillageBuilding {
    pub fn center(&self) -> (usize, usize) {
        (self.x + self.width / 2, self.y + self.height / 2)
    }
}

/// Generate a village with buildings, roads, and a central plaza
pub fn generate_village(
    chunk: &mut LocalChunk,
    surface_z: i16,
    rng: &mut ChaCha8Rng,
) {
    let center_x = LOCAL_SIZE / 2;
    let center_y = LOCAL_SIZE / 2;

    // Generate central plaza/well
    let plaza_radius = rng.gen_range(4..7);
    generate_plaza(chunk, center_x, center_y, plaza_radius, surface_z, rng);

    // Determine number of buildings (3-7)
    let num_buildings = rng.gen_range(3..8);

    // Place buildings around the plaza
    let mut buildings: Vec<VillageBuilding> = Vec::new();

    for i in 0..num_buildings {
        // Try to place building
        for _ in 0..20 {
            let angle = (i as f64 / num_buildings as f64) * std::f64::consts::TAU
                + rng.gen_range(-0.3..0.3);
            let dist = rng.gen_range((plaza_radius + 8) as f64..18.0);

            let bx = (center_x as f64 + angle.cos() * dist) as usize;
            let by = (center_y as f64 + angle.sin() * dist) as usize;

            let width = rng.gen_range(6..10);
            let height = rng.gen_range(5..8);

            // Check bounds
            if bx < 3 || by < 3 || bx + width > LOCAL_SIZE - 3 || by + height > LOCAL_SIZE - 3 {
                continue;
            }

            // Check for overlap with existing buildings
            let overlaps = buildings.iter().any(|b| {
                let margin = 2;
                bx < b.x + b.width + margin &&
                bx + width + margin > b.x &&
                by < b.y + b.height + margin &&
                by + height + margin > b.y
            });

            if !overlaps {
                let building_type = match rng.gen_range(0..10) {
                    0 => BuildingType::Tavern,
                    1 => BuildingType::Shop,
                    2 => BuildingType::Blacksmith,
                    3 => BuildingType::Chapel,
                    4 => BuildingType::StorageHut,
                    5 => BuildingType::Farm,
                    _ => BuildingType::House,
                };

                buildings.push(VillageBuilding {
                    x: bx,
                    y: by,
                    width,
                    height,
                    building_type,
                    has_garden: rng.gen_bool(0.4),
                });
                break;
            }
        }
    }

    // Generate each building
    for building in &buildings {
        generate_building(chunk, building, surface_z, rng);
    }

    // Connect buildings with roads
    generate_village_roads(chunk, &buildings, center_x, center_y, plaza_radius, surface_z, rng);

    // Add ambient features
    add_village_ambiance(chunk, &buildings, surface_z, rng);
}

/// Generate a central plaza with well or fountain
fn generate_plaza(
    chunk: &mut LocalChunk,
    cx: usize,
    cy: usize,
    radius: usize,
    z: i16,
    rng: &mut ChaCha8Rng,
) {
    // Cobblestone plaza floor
    for dy in -(radius as i32)..=(radius as i32) {
        for dx in -(radius as i32)..=(radius as i32) {
            let dist = ((dx * dx + dy * dy) as f32).sqrt();
            if dist <= radius as f32 {
                let x = (cx as i32 + dx).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
                let y = (cy as i32 + dy).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
                chunk.set(x, y, z, LocalTile::new(LocalTerrain::Cobblestone, Material::Stone));
            }
        }
    }

    // Central well or fountain
    if rng.gen_bool(0.6) {
        // Well
        chunk.get_mut(cx, cy, z).feature = LocalFeature::Well;
    } else {
        // Fountain (use altar as placeholder)
        chunk.get_mut(cx, cy, z).feature = LocalFeature::Altar;
    }

    // Optional benches (pillars as placeholder)
    if rng.gen_bool(0.5) {
        for (dx, dy) in [(2, 0), (-2, 0), (0, 2), (0, -2)] {
            let bx = (cx as i32 + dx).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
            let by = (cy as i32 + dy).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
            if chunk.get(bx, by, z).feature == LocalFeature::None {
                chunk.get_mut(bx, by, z).feature = LocalFeature::Pillar;
            }
        }
    }
}

/// Generate a single building
fn generate_building(
    chunk: &mut LocalChunk,
    building: &VillageBuilding,
    z: i16,
    rng: &mut ChaCha8Rng,
) {
    let (x1, y1, w, h) = (building.x, building.y, building.width, building.height);

    // Determine door position (on south wall by default, or random wall)
    let door_wall = rng.gen_range(0..4);
    let (door_x, door_y) = match door_wall {
        0 => (x1 + w / 2, y1), // North
        1 => (x1 + w / 2, y1 + h - 1), // South
        2 => (x1, y1 + h / 2), // West
        _ => (x1 + w - 1, y1 + h / 2), // East
    };

    // Build walls and floor
    for y in y1..y1 + h {
        for x in x1..x1 + w {
            if x < LOCAL_SIZE && y < LOCAL_SIZE {
                let is_wall = x == x1 || x == x1 + w - 1 || y == y1 || y == y1 + h - 1;
                let is_door = x == door_x && y == door_y;

                if is_door {
                    chunk.set(x, y, z, LocalTile::new(
                        LocalTerrain::WoodFloor,
                        Material::Dirt
                    ));
                    chunk.get_mut(x, y, z).feature = LocalFeature::Door { open: false };
                } else if is_wall {
                    chunk.set(x, y, z, LocalTile::new(
                        LocalTerrain::ConstructedWall { material: Material::Dirt },
                        Material::Dirt
                    ));
                } else {
                    chunk.set(x, y, z, LocalTile::new(
                        LocalTerrain::WoodFloor,
                        Material::Dirt
                    ));
                }
            }
        }
    }

    // Add interior features based on building type
    add_building_interior(chunk, building, z, rng);

    // Add garden if applicable
    if building.has_garden {
        add_building_garden(chunk, building, z, rng);
    }
}

/// Add interior features based on building type
fn add_building_interior(
    chunk: &mut LocalChunk,
    building: &VillageBuilding,
    z: i16,
    rng: &mut ChaCha8Rng,
) {
    let (cx, cy) = building.center();

    match building.building_type {
        BuildingType::House => {
            // Bed (rubble as placeholder)
            let bed_x = building.x + 1;
            let bed_y = building.y + 1;
            if bed_x < LOCAL_SIZE && bed_y < LOCAL_SIZE {
                chunk.get_mut(bed_x, bed_y, z).feature = LocalFeature::Rubble;
            }
            // Torch
            if cx < LOCAL_SIZE && cy < LOCAL_SIZE {
                chunk.get_mut(cx, cy, z).feature = LocalFeature::Torch;
            }
        }
        BuildingType::Tavern => {
            // Tables (barrels as placeholder)
            for i in 0..rng.gen_range(2..4) {
                let tx = building.x + 2 + i * 2;
                let ty = building.y + building.height / 2;
                if tx < building.x + building.width - 2 && tx < LOCAL_SIZE && ty < LOCAL_SIZE {
                    chunk.get_mut(tx, ty, z).feature = LocalFeature::Barrel;
                }
            }
            // Bar counter (pillars)
            let bar_y = building.y + 1;
            for x in building.x + 1..building.x + building.width - 1 {
                if x < LOCAL_SIZE && bar_y < LOCAL_SIZE && rng.gen_bool(0.7) {
                    chunk.get_mut(x, bar_y, z).feature = LocalFeature::Pillar;
                }
            }
            // Torches
            chunk.get_mut(building.x + 1, building.y + building.height - 2, z).feature = LocalFeature::Torch;
        }
        BuildingType::Shop => {
            // Shelves (pillars)
            for y in (building.y + 1..building.y + building.height - 1).step_by(2) {
                let shelf_x = building.x + 1;
                if shelf_x < LOCAL_SIZE && y < LOCAL_SIZE {
                    chunk.get_mut(shelf_x, y, z).feature = LocalFeature::Pillar;
                }
            }
            // Counter
            let counter_x = building.x + building.width - 2;
            let counter_y = building.y + building.height / 2;
            if counter_x < LOCAL_SIZE && counter_y < LOCAL_SIZE {
                chunk.get_mut(counter_x, counter_y, z).feature = LocalFeature::Barrel;
            }
        }
        BuildingType::Blacksmith => {
            // Forge (use altar as placeholder)
            let forge_x = building.x + 1;
            let forge_y = building.y + 1;
            if forge_x < LOCAL_SIZE && forge_y < LOCAL_SIZE {
                chunk.get_mut(forge_x, forge_y, z).feature = LocalFeature::Altar;
            }
            // Anvil (pillar)
            if cx < LOCAL_SIZE && cy < LOCAL_SIZE {
                chunk.get_mut(cx, cy, z).feature = LocalFeature::Pillar;
            }
            // Barrels with water/supplies
            let barrel_x = building.x + building.width - 2;
            let barrel_y = building.y + building.height - 2;
            if barrel_x < LOCAL_SIZE && barrel_y < LOCAL_SIZE {
                chunk.get_mut(barrel_x, barrel_y, z).feature = LocalFeature::Barrel;
            }
        }
        BuildingType::Chapel => {
            // Altar at far end
            let altar_x = cx;
            let altar_y = building.y + 1;
            if altar_x < LOCAL_SIZE && altar_y < LOCAL_SIZE {
                chunk.get_mut(altar_x, altar_y, z).feature = LocalFeature::Altar;
            }
            // Pews (pillars in rows)
            for row in 0..2 {
                let pew_y = building.y + 3 + row * 2;
                for i in 0..3 {
                    let pew_x = building.x + 2 + i * 2;
                    if pew_x < building.x + building.width - 2 && pew_x < LOCAL_SIZE && pew_y < LOCAL_SIZE {
                        chunk.get_mut(pew_x, pew_y, z).feature = LocalFeature::Pillar;
                    }
                }
            }
            // Torches by altar
            if altar_x > 1 && altar_x + 1 < LOCAL_SIZE && altar_y < LOCAL_SIZE {
                chunk.get_mut(altar_x - 1, altar_y, z).feature = LocalFeature::Torch;
                chunk.get_mut(altar_x + 1, altar_y, z).feature = LocalFeature::Torch;
            }
        }
        BuildingType::StorageHut => {
            // Barrels and crates (barrels and rubble)
            for _ in 0..rng.gen_range(4..8) {
                let bx = rng.gen_range(building.x + 1..building.x + building.width - 1);
                let by = rng.gen_range(building.y + 1..building.y + building.height - 1);
                if bx < LOCAL_SIZE && by < LOCAL_SIZE && chunk.get(bx, by, z).feature == LocalFeature::None {
                    if rng.gen_bool(0.5) {
                        chunk.get_mut(bx, by, z).feature = LocalFeature::Barrel;
                    } else {
                        chunk.get_mut(bx, by, z).feature = LocalFeature::Rubble;
                    }
                }
            }
        }
        BuildingType::Farm => {
            // Simple interior - just a bed
            let bed_x = building.x + 1;
            let bed_y = building.y + 1;
            if bed_x < LOCAL_SIZE && bed_y < LOCAL_SIZE {
                chunk.get_mut(bed_x, bed_y, z).feature = LocalFeature::Rubble;
            }
        }
    }
}

/// Add a garden around a building
fn add_building_garden(
    chunk: &mut LocalChunk,
    building: &VillageBuilding,
    z: i16,
    rng: &mut ChaCha8Rng,
) {
    // Determine which side to place garden
    let garden_side = rng.gen_range(0..4);

    let (gx1, gy1, gw, gh) = match garden_side {
        0 => (building.x, building.y.saturating_sub(4), building.width, 3), // North
        1 => (building.x, building.y + building.height + 1, building.width, 3), // South
        2 => (building.x.saturating_sub(4), building.y, 3, building.height), // West
        _ => (building.x + building.width + 1, building.y, 3, building.height), // East
    };

    // Check bounds
    if gx1 + gw > LOCAL_SIZE || gy1 + gh > LOCAL_SIZE {
        return;
    }

    // Place garden tiles
    for y in gy1..gy1 + gh {
        for x in gx1..gx1 + gw {
            if x < LOCAL_SIZE && y < LOCAL_SIZE {
                chunk.set(x, y, z, LocalTile::new(LocalTerrain::DirtFloor, Material::Dirt));

                // Plant something
                if rng.gen_bool(0.4) {
                    chunk.get_mut(x, y, z).feature = LocalFeature::Bush;
                }
            }
        }
    }

    // Add fence around garden (pillars)
    if rng.gen_bool(0.5) {
        for x in gx1..gx1 + gw {
            if x < LOCAL_SIZE {
                if gy1 > 0 && chunk.get(x, gy1, z).feature == LocalFeature::None {
                    chunk.get_mut(x, gy1, z).feature = LocalFeature::Pillar;
                }
                if gy1 + gh - 1 < LOCAL_SIZE && chunk.get(x, gy1 + gh - 1, z).feature == LocalFeature::None {
                    chunk.get_mut(x, gy1 + gh - 1, z).feature = LocalFeature::Pillar;
                }
            }
        }
    }
}

/// Generate roads connecting buildings to the plaza
fn generate_village_roads(
    chunk: &mut LocalChunk,
    buildings: &[VillageBuilding],
    plaza_x: usize,
    plaza_y: usize,
    plaza_radius: usize,
    z: i16,
    _rng: &mut ChaCha8Rng,
) {
    for building in buildings {
        // Find the building's closest edge to plaza
        let (door_x, door_y) = building.center();

        // Draw path from building to plaza edge
        let dx = plaza_x as i32 - door_x as i32;
        let dy = plaza_y as i32 - door_y as i32;

        // Normalize to plaza edge
        let dist = ((dx * dx + dy * dy) as f32).sqrt();
        let edge_x = plaza_x as i32 - (dx as f32 / dist * (plaza_radius + 1) as f32) as i32;
        let edge_y = plaza_y as i32 - (dy as f32 / dist * (plaza_radius + 1) as f32) as i32;

        // Draw L-shaped path
        let mid_x = door_x;
        let mid_y = edge_y as usize;

        // Horizontal segment
        let (start_x, end_x) = if door_x < edge_x as usize {
            (door_x, edge_x as usize)
        } else {
            (edge_x as usize, door_x)
        };

        for x in start_x..=end_x.min(LOCAL_SIZE - 1) {
            if mid_y < LOCAL_SIZE {
                let tile = chunk.get(x, mid_y, z);
                if !matches!(tile.terrain, LocalTerrain::Cobblestone)
                    && !matches!(tile.terrain, LocalTerrain::ConstructedWall { .. })
                    && !matches!(tile.terrain, LocalTerrain::WoodFloor)
                {
                    chunk.set(x, mid_y, z, LocalTile::new(LocalTerrain::DirtFloor, Material::Dirt));
                }
            }
        }

        // Vertical segment
        let (start_y, end_y) = if door_y < mid_y {
            (door_y, mid_y)
        } else {
            (mid_y, door_y)
        };

        for y in start_y..=end_y.min(LOCAL_SIZE - 1) {
            if door_x < LOCAL_SIZE {
                let tile = chunk.get(door_x, y, z);
                if !matches!(tile.terrain, LocalTerrain::Cobblestone)
                    && !matches!(tile.terrain, LocalTerrain::ConstructedWall { .. })
                    && !matches!(tile.terrain, LocalTerrain::WoodFloor)
                {
                    chunk.set(door_x, y, z, LocalTile::new(LocalTerrain::DirtFloor, Material::Dirt));
                }
            }
        }
    }
}

/// Add ambient village features (trees, animals, etc.)
fn add_village_ambiance(
    chunk: &mut LocalChunk,
    buildings: &[VillageBuilding],
    z: i16,
    rng: &mut ChaCha8Rng,
) {
    // Add trees around village perimeter
    for _ in 0..rng.gen_range(5..15) {
        let x = rng.gen_range(2..LOCAL_SIZE - 2);
        let y = rng.gen_range(2..LOCAL_SIZE - 2);

        // Check not inside building
        let inside_building = buildings.iter().any(|b| {
            x >= b.x.saturating_sub(1) && x < b.x + b.width + 1 &&
            y >= b.y.saturating_sub(1) && y < b.y + b.height + 1
        });

        if !inside_building {
            let tile = chunk.get(x, y, z);
            if tile.feature == LocalFeature::None
                && !matches!(tile.terrain, LocalTerrain::Cobblestone)
                && !matches!(tile.terrain, LocalTerrain::ConstructedWall { .. })
                && !matches!(tile.terrain, LocalTerrain::WoodFloor)
            {
                chunk.get_mut(x, y, z).feature = LocalFeature::Tree { height: rng.gen_range(3..7) };
            }
        }
    }

    // Add some bushes
    for _ in 0..rng.gen_range(8..20) {
        let x = rng.gen_range(2..LOCAL_SIZE - 2);
        let y = rng.gen_range(2..LOCAL_SIZE - 2);

        let inside_building = buildings.iter().any(|b| {
            x >= b.x && x < b.x + b.width && y >= b.y && y < b.y + b.height
        });

        if !inside_building && chunk.get(x, y, z).feature == LocalFeature::None {
            chunk.get_mut(x, y, z).feature = LocalFeature::Bush;
        }
    }

    // Add occasional torch or well outside
    if rng.gen_bool(0.3) {
        for _ in 0..rng.gen_range(1..3) {
            let x = rng.gen_range(5..LOCAL_SIZE - 5);
            let y = rng.gen_range(5..LOCAL_SIZE - 5);
            if chunk.get(x, y, z).feature == LocalFeature::None {
                chunk.get_mut(x, y, z).feature = LocalFeature::Torch;
            }
        }
    }
}

/// Generate a castle or fortress structure
pub fn generate_castle(
    chunk: &mut LocalChunk,
    surface_z: i16,
    rng: &mut ChaCha8Rng,
) {
    let center_x = LOCAL_SIZE / 2;
    let center_y = LOCAL_SIZE / 2;

    // Outer wall dimensions
    let wall_size = rng.gen_range(32..42);
    let wall_half = wall_size / 2;
    let wall_thickness = 2;

    let x1 = center_x.saturating_sub(wall_half);
    let y1 = center_y.saturating_sub(wall_half);
    let x2 = (center_x + wall_half).min(LOCAL_SIZE - 1);
    let y2 = (center_y + wall_half).min(LOCAL_SIZE - 1);

    // Build outer walls
    for y in y1..=y2 {
        for x in x1..=x2 {
            let at_wall = (x >= x1 && x < x1 + wall_thickness) ||
                         (x > x2 - wall_thickness && x <= x2) ||
                         (y >= y1 && y < y1 + wall_thickness) ||
                         (y > y2 - wall_thickness && y <= y2);

            if at_wall {
                chunk.set(x, y, surface_z, LocalTile::new(
                    LocalTerrain::ConstructedWall { material: Material::Stone },
                    Material::Stone
                ));
            } else {
                // Interior courtyard
                chunk.set(x, y, surface_z, LocalTile::new(
                    LocalTerrain::Cobblestone,
                    Material::Stone
                ));
            }
        }
    }

    // Add corner towers (circular)
    let corners = [(x1, y1), (x2, y1), (x1, y2), (x2, y2)];
    let tower_radius = 4;
    for (cx, cy) in corners {
        for dy in -(tower_radius as i32)..=(tower_radius as i32) {
            for dx in -(tower_radius as i32)..=(tower_radius as i32) {
                let dist = ((dx * dx + dy * dy) as f32).sqrt();
                if dist <= tower_radius as f32 {
                    let tx = (cx as i32 + dx).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
                    let ty = (cy as i32 + dy).clamp(0, LOCAL_SIZE as i32 - 1) as usize;

                    if dist > (tower_radius - 2) as f32 {
                        chunk.set(tx, ty, surface_z, LocalTile::new(
                            LocalTerrain::ConstructedWall { material: Material::Stone },
                            Material::Stone
                        ));
                    } else {
                        chunk.set(tx, ty, surface_z, LocalTile::new(
                            LocalTerrain::ConstructedFloor { material: Material::Stone },
                            Material::Stone
                        ));
                    }
                }
            }
        }
        // Stairs in towers
        chunk.get_mut(cx, cy, surface_z).feature = LocalFeature::StairsUp;
    }

    // Main gate (south wall)
    let gate_x = center_x;
    let gate_width = 4;
    for x in (gate_x - gate_width / 2)..(gate_x + gate_width / 2) {
        for y in y2 - wall_thickness + 1..=y2 {
            if x < LOCAL_SIZE && y < LOCAL_SIZE {
                chunk.set(x, y, surface_z, LocalTile::new(
                    LocalTerrain::ConstructedFloor { material: Material::Stone },
                    Material::Stone
                ));
            }
        }
    }
    // Gate doors
    chunk.get_mut(gate_x - 1, y2, surface_z).feature = LocalFeature::Door { open: false };
    chunk.get_mut(gate_x, y2, surface_z).feature = LocalFeature::Door { open: false };

    // Keep (central building)
    let keep_size = rng.gen_range(10..14);
    let keep_half = keep_size / 2;
    let kx1 = center_x - keep_half;
    let ky1 = center_y - keep_half;
    let kx2 = center_x + keep_half;
    let ky2 = center_y + keep_half;

    for y in ky1..=ky2 {
        for x in kx1..=kx2 {
            if x < LOCAL_SIZE && y < LOCAL_SIZE {
                let is_wall = x == kx1 || x == kx2 || y == ky1 || y == ky2;
                let is_door = x == center_x && y == ky2;

                if is_door {
                    chunk.set(x, y, surface_z, LocalTile::new(
                        LocalTerrain::ConstructedFloor { material: Material::Stone },
                        Material::Stone
                    ));
                    chunk.get_mut(x, y, surface_z).feature = LocalFeature::Door { open: false };
                } else if is_wall {
                    chunk.set(x, y, surface_z, LocalTile::new(
                        LocalTerrain::ConstructedWall { material: Material::Stone },
                        Material::Stone
                    ));
                } else {
                    chunk.set(x, y, surface_z, LocalTile::new(
                        LocalTerrain::ConstructedFloor { material: Material::Stone },
                        Material::Stone
                    ));
                }
            }
        }
    }

    // Keep interior - throne room
    chunk.get_mut(center_x, center_y - 2, surface_z).feature = LocalFeature::Altar; // Throne
    chunk.get_mut(center_x - 2, center_y - 2, surface_z).feature = LocalFeature::Torch;
    chunk.get_mut(center_x + 2, center_y - 2, surface_z).feature = LocalFeature::Torch;

    // Stairs down in keep (to dungeon)
    chunk.get_mut(center_x, center_y + 2, surface_z).feature = LocalFeature::StairsDown;

    // Barracks along one wall
    let barracks_x = x1 + wall_thickness + 2;
    let barracks_y = y1 + wall_thickness + 2;
    for y in barracks_y..barracks_y + 6 {
        for x in barracks_x..barracks_x + 10 {
            if x < LOCAL_SIZE && y < LOCAL_SIZE {
                let is_wall = y == barracks_y || y == barracks_y + 5 ||
                             x == barracks_x || x == barracks_x + 9;
                if is_wall {
                    chunk.set(x, y, surface_z, LocalTile::new(
                        LocalTerrain::ConstructedWall { material: Material::Dirt },
                        Material::Dirt
                    ));
                } else {
                    chunk.set(x, y, surface_z, LocalTile::new(
                        LocalTerrain::WoodFloor,
                        Material::Dirt
                    ));
                }
            }
        }
    }

    // Well in courtyard
    chunk.get_mut(x2 - wall_thickness - 5, center_y, surface_z).feature = LocalFeature::Well;
}

/// Generate a mine entrance and shaft
pub fn generate_mine(
    chunk: &mut LocalChunk,
    surface_z: i16,
    num_levels: usize,
    rng: &mut ChaCha8Rng,
) {
    let center_x = LOCAL_SIZE / 2;
    let center_y = LOCAL_SIZE / 2;

    // Mine entrance structure
    let entrance_width = 8;
    let entrance_height = 6;
    let ex1 = center_x - entrance_width / 2;
    let ey1 = center_y - entrance_height / 2;

    // Build entrance building
    for y in ey1..ey1 + entrance_height {
        for x in ex1..ex1 + entrance_width {
            if x < LOCAL_SIZE && y < LOCAL_SIZE {
                let is_wall = x == ex1 || x == ex1 + entrance_width - 1 ||
                             y == ey1 || y == ey1 + entrance_height - 1;
                let is_door = x == center_x && y == ey1 + entrance_height - 1;

                if is_door {
                    chunk.set(x, y, surface_z, LocalTile::new(
                        LocalTerrain::WoodFloor,
                        Material::Dirt
                    ));
                    chunk.get_mut(x, y, surface_z).feature = LocalFeature::Door { open: false };
                } else if is_wall {
                    chunk.set(x, y, surface_z, LocalTile::new(
                        LocalTerrain::ConstructedWall { material: Material::Dirt },
                        Material::Dirt
                    ));
                } else {
                    chunk.set(x, y, surface_z, LocalTile::new(
                        LocalTerrain::WoodFloor,
                        Material::Dirt
                    ));
                }
            }
        }
    }

    // Stairs down in center of entrance building
    chunk.get_mut(center_x, center_y, surface_z).feature = LocalFeature::StairsDown;

    // Mine cart tracks (pillars leading to entrance)
    for i in 0..8 {
        let track_y = ey1 + entrance_height + i;
        if track_y < LOCAL_SIZE {
            chunk.set(center_x, track_y, surface_z, LocalTile::new(
                LocalTerrain::DirtFloor,
                Material::Dirt
            ));
            if i % 2 == 0 {
                chunk.get_mut(center_x, track_y, surface_z).feature = LocalFeature::Pillar;
            }
        }
    }

    // Equipment storage nearby
    for dx in [-5i32, 5] {
        let storage_x = (center_x as i32 + dx).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
        let storage_y = ey1 + entrance_height + 2;
        if storage_y < LOCAL_SIZE {
            chunk.get_mut(storage_x, storage_y, surface_z).feature = LocalFeature::Barrel;
        }
    }

    // Generate mine tunnels underground
    for level in 0..num_levels {
        let z = surface_z - 1 - level as i16;
        if z < chunk.z_min {
            break;
        }

        // Main shaft continuing down
        chunk.set(center_x, center_y, z, LocalTile::new(
            LocalTerrain::StoneFloor,
            Material::Stone
        ));

        if level == 0 {
            chunk.get_mut(center_x, center_y, z).feature = LocalFeature::StairsUp;
        }

        // Branch tunnels
        let num_branches = rng.gen_range(2..5);
        for branch in 0..num_branches {
            let angle = (branch as f64 / num_branches as f64) * std::f64::consts::TAU
                + rng.gen_range(-0.3..0.3);
            let length = rng.gen_range(8..20);

            for i in 0..length {
                let tx = (center_x as f64 + angle.cos() * i as f64) as usize;
                let ty = (center_y as f64 + angle.sin() * i as f64) as usize;

                if tx < LOCAL_SIZE && ty < LOCAL_SIZE {
                    chunk.set(tx, ty, z, LocalTile::new(
                        LocalTerrain::StoneFloor,
                        Material::Stone
                    ));

                    // Occasional support pillar
                    if i > 2 && i % 4 == 0 && rng.gen_bool(0.5) {
                        chunk.get_mut(tx, ty, z).feature = LocalFeature::Pillar;
                    }

                    // Ore vein markers (boulders)
                    if i > 5 && rng.gen_bool(0.1) {
                        chunk.get_mut(tx, ty, z).feature = LocalFeature::Boulder;
                    }

                    // Torch every few tiles
                    if i > 0 && i % 6 == 0 && chunk.get(tx, ty, z).feature == LocalFeature::None {
                        chunk.get_mut(tx, ty, z).feature = LocalFeature::Torch;
                    }
                }
            }

            // Dead end or side chamber
            if rng.gen_bool(0.4) {
                let end_x = (center_x as f64 + angle.cos() * length as f64) as usize;
                let end_y = (center_y as f64 + angle.sin() * length as f64) as usize;

                // Small chamber
                let chamber_radius = rng.gen_range(2..4);
                for dy in -(chamber_radius as i32)..=(chamber_radius as i32) {
                    for dx in -(chamber_radius as i32)..=(chamber_radius as i32) {
                        let cx = (end_x as i32 + dx).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
                        let cy = (end_y as i32 + dy).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
                        let dist = ((dx * dx + dy * dy) as f32).sqrt();
                        if dist <= chamber_radius as f32 {
                            chunk.set(cx, cy, z, LocalTile::new(
                                LocalTerrain::StoneFloor,
                                Material::Stone
                            ));
                        }
                    }
                }

                // Occasional chest in chamber
                if rng.gen_bool(0.3) && end_x < LOCAL_SIZE && end_y < LOCAL_SIZE {
                    chunk.get_mut(end_x, end_y, z).feature = LocalFeature::Chest;
                }
            }
        }

        // Stairs to next level
        if level + 1 < num_levels {
            let offset_x = rng.gen_range(-3i32..4);
            let offset_y = rng.gen_range(-3i32..4);
            let stair_x = (center_x as i32 + offset_x).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
            let stair_y = (center_y as i32 + offset_y).clamp(0, LOCAL_SIZE as i32 - 1) as usize;
            if stair_x < LOCAL_SIZE && stair_y < LOCAL_SIZE {
                chunk.set(stair_x, stair_y, z, LocalTile::new(
                    LocalTerrain::StoneFloor,
                    Material::Stone
                ));
                chunk.get_mut(stair_x, stair_y, z).feature = LocalFeature::StairsDown;

                // Stairs up on the level below
                let below_z = z - 1;
                if below_z >= chunk.z_min {
                    chunk.set(stair_x, stair_y, below_z, LocalTile::new(
                        LocalTerrain::StoneFloor,
                        Material::Stone
                    ));
                    chunk.get_mut(stair_x, stair_y, below_z).feature = LocalFeature::StairsUp;
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rand::SeedableRng;

    #[test]
    fn test_bsp_generation() {
        let mut rng = ChaCha8Rng::seed_from_u64(42);
        let mut root = BspNode::new(0, 0, 48, 48);
        root.split(&mut rng, MIN_NODE_SIZE, 3);
        root.generate_rooms(&mut rng);

        let rooms = root.collect_rooms();
        assert!(!rooms.is_empty());

        // All rooms should be within bounds
        for room in &rooms {
            assert!(room.x + room.width <= 48);
            assert!(room.y + room.height <= 48);
        }
    }

    #[test]
    fn test_dungeon_generation() {
        let mut chunk = super::super::local::LocalChunk::new(0, 0, 5);
        let mut rng = ChaCha8Rng::seed_from_u64(42);

        let rooms = generate_dungeon_bsp(&mut chunk, 0, &mut rng);
        assert!(!rooms.is_empty());

        // Check that rooms are carved
        let (cx, cy) = rooms[0].center();
        assert!(chunk.get(cx, cy, 0).terrain.is_passable());
    }

    #[test]
    fn test_village_generation() {
        let mut chunk = super::super::local::LocalChunk::new(0, 0, 5);
        let mut rng = ChaCha8Rng::seed_from_u64(42);

        generate_village(&mut chunk, 0, &mut rng);

        // Check that plaza is generated in center
        let center = LOCAL_SIZE / 2;
        let center_tile = chunk.get(center, center, 0);
        // Plaza should have a well or altar
        assert!(
            center_tile.feature == LocalFeature::Well ||
            center_tile.feature == LocalFeature::Altar
        );

        // Check that cobblestone plaza exists
        let plaza_tile = chunk.get(center + 1, center, 0);
        assert!(matches!(plaza_tile.terrain, LocalTerrain::Cobblestone));
    }

    #[test]
    fn test_castle_generation() {
        let mut chunk = super::super::local::LocalChunk::new(0, 0, 5);
        let mut rng = ChaCha8Rng::seed_from_u64(42);

        generate_castle(&mut chunk, 0, &mut rng);

        // Check that keep is in center
        let center = LOCAL_SIZE / 2;
        let keep_tile = chunk.get(center, center, 0);
        // Inside keep should be floor
        assert!(matches!(keep_tile.terrain, LocalTerrain::ConstructedFloor { .. }));

        // Check that courtyard has cobblestone (center + some offset should be courtyard)
        let courtyard_tile = chunk.get(center + 5, center, 0);
        assert!(matches!(courtyard_tile.terrain, LocalTerrain::Cobblestone) ||
                matches!(courtyard_tile.terrain, LocalTerrain::ConstructedFloor { .. }) ||
                matches!(courtyard_tile.terrain, LocalTerrain::ConstructedWall { .. }));
    }

    #[test]
    fn test_mine_generation() {
        let mut chunk = super::super::local::LocalChunk::new(0, 0, 5);
        let mut rng = ChaCha8Rng::seed_from_u64(42);

        generate_mine(&mut chunk, 0, 3, &mut rng);

        // Check that entrance has stairs down
        let center = LOCAL_SIZE / 2;
        let entrance_tile = chunk.get(center, center, 0);
        assert!(entrance_tile.feature == LocalFeature::StairsDown);

        // Check that first underground level has stone floor (tunnels generated)
        let first_level_tile = chunk.get(center, center, -1);
        // First level should have stone floor with stairs up at the main shaft
        assert!(matches!(first_level_tile.terrain, LocalTerrain::StoneFloor) ||
                first_level_tile.feature == LocalFeature::StairsUp);
    }
}
